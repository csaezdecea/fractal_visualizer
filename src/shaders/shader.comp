#version 430 core
#extension GL_ARB_gpu_shader_fp64 : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba32f) uniform writeonly image2D outImage;

// Uniforms
uniform dvec2 center;
uniform double zoom;
uniform int option;
uniform int maxIterations;
uniform ivec2 resolution;

// ===============================
// Double Mandelbrot — now outputs last zr,zi
// ===============================
int computeDoubleMandelbrot(double cr, double ci, int maxI,
                            out double zrOut, out double ziOut)
{
    double zr = 0.0, zi = 0.0;
    int iter = 0;

    while (iter < maxI)
    {
        double tmp = zr;
        zr = zr*zr - zi*zi + cr;
        zi = 2.0 * tmp * zi + ci;

        if (zr*zr + zi*zi > 4.0) break;
        iter++;
    }

    zrOut = zr;
    ziOut = zi;
    return iter;
}

// ===============================
// Double Julia — now outputs last zr,zi
// ===============================
int computeDoubleJulia(double zr, double zi, double cr, double ci,
                       int maxI, out double zrOut, out double ziOut)
{
    int iter = 0;

    while (iter < maxI)
    {
        double tmp = zr;
        zr = zr*zr - zi*zi + cr;
        zi = 2.0 * tmp * zi + ci;

        if (zr*zr + zi*zi > 4.0) break;
        iter++;
    }

    zrOut = zr;
    ziOut = zi;
    return iter;
}

// ===============================
// Smooth escape
// ===============================
float smoothEscape(int iter, double zr, double zi)
{
    float fr = float(zr);
    float fi = float(zi);
    float mag2 = fr*fr + fi*fi;

    if (mag2 < 1e-12) mag2 = 1e-12;

    return float(iter) + 1.0 - log(log(sqrt(mag2))) / log(2.0);
}

// ===============================
// Dispatcher — updated to retrieve zr, zi
// ===============================
int fractalIterations(int op, double real, double imag,
                      out double zrOut, out double ziOut)
{
    if (op == 1) {
        return computeDoubleMandelbrot(real, imag, maxIterations, zrOut, ziOut);

    } else if (op == 2) {
        // exp variant (kept as float version)
        float r = float(real), i = float(imag);
        int iter = computeFloatExpVariant(r, i, maxIterations);
        zrOut = real; ziOut = imag; // no sharp z data for float version
        return iter;

    } else if (op == 3) {
        double cr = 0.279;
        double ci = 0.0;
        return computeDoubleJulia(real, imag, cr, ci, maxIterations, zrOut, ziOut);

    } else {
        float r = float(real), i = float(imag);
        int iter = computeFloatExpJulia(r, i, maxIterations);
        zrOut = real; ziOut = imag;
        return iter;
    }
}

void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= resolution.x || gid.y >= resolution.y) return;

    // ↑ Improved precision: removed *5.0 scaling
    double fx = double(gid.x) / double(resolution.x) - 0.5;
    double fy = double(gid.y) / double(resolution.y) - 0.5;

    double real = fx * zoom + center.x;
    double imag = fy * zoom + center.y;

    double zr, zi;
    int iter = fractalIterations(option, real, imag, zr, zi);

    // ===============================
    // Sharp color via smooth escape
    // ===============================
    float smooth = smoothEscape(iter, zr, zi);
    float norm = smooth / float(maxIterations);

    vec4 color;

    if (iter >= maxIterations) {
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else {

        float maxa = 50.0;
        if (option == 1) maxa = 400.0;
        if (option == 2) maxa = 80.0;
        if (option == 3) maxa = 40.0;
        if (option == 4) maxa = 20.0;

        float ita = norm * (float(maxIterations) / maxa);

        if (float(iter) < maxa) {
            color = vec4(0.0, ita, 0.0, 1.0);
        } else {
            color = vec4(0.1, 0.4, 0.4, 1.0);
        }
    }

    imageStore(outImage, gid, color);
}
